daily acm training record

# 2022.9.1

之前的东西太多了，没有记录

# 2022.9.3

## [2303](2303.cpp)

简单欧拉函数板子题，只要枚举因数进行计算即可。

## [P5657](5657.cpp)

通过定义生成格雷码就行了

# 2022.9.4

## [2015](2015.cpp)

开始学习基础树形dp

## [2014](2014.cpp)

有依赖的背包类似P2015

## [2016](2016.cpp)

入门级树形dp

## [CF219D](CF219D.cpp)

树形dp水题

## [3478](3478.cpp)

入门级树形dp

## [1270](1270.cpp)

读题题

## [1131](1131.cpp)

树形dp水题

achieve:昨天vp计算几何补题，7个入门树形dp

tomorrow plan:学习容斥原理和莫反，继续刷入门树形dp，有空的话vp一场cf

# 2022.9.5

看了一天容斥原理，发现非常得难，开始了递归学习。

## tomorrow plan

学习容斥原理和莫反，继续刷入门树形dp，有空的话vp一场cf

# 2022.9.6

依旧是看了一天得容斥

# 2022.9.7

vp了一场

# 2022.9.8

## [3455](3455.cpp)

莫反入门题

## [4450](4450.cpp)

莫反入门题

## [2522](2522.cpp)

莫反+容斥

# 2022.9.20

## [2986](2986.cpp)

换根dp

# 2022.9.22

## [sp7001](sp7001.cpp)

莫反入门题

# 2022.9.24

## [UVA10891](UVA10891.cpp)

区间dp

## [hdu4746](HDU4746.cpp)

莫反+数论分块

## [hdu5528](HDU5528.cpp)

积性函数+枚举素因子

# 2022.9.27

## [CFGYM100287C](CFGYM100287C.cpp)

循环矩阵的性质

## [UVA12879](UVA12879.cpp)

fft板子

## [CF461B](CF461B.cpp)

树形dp基础题

## [CF708C](CF708C.cpp)

树形dp要点思维题

# 2022.10.4

## [1196](1196.cpp)

带权并查集板子

# 2022.10.5

## [3807](3807.cpp)

lucas板子

# 2022.10.28

## [CFGYM103447G](CFGYM103447G.cpp)

图上概率dp

# 2023.2.20

## [CF466C](CF466C.cpp)

前缀和简单题

## [CF474D](CF474D.cpp)

简单dp

## [CF339D](CF339D.cpp)

考虑每一层的数字，暴力更新

# 2023.2.21

开始复健一下简单题

## [CF118D](CF118D.cpp)

简单dp

## [CF1365D](CF1365D.cpp)

简单bfs

## [CF467C](CF467C.cpp)

简单dp

# 2023.2.23

## [CF977F](CF977F.cpp)

记录前驱的简单dp

# 2023.25

打了cf1789

但是因为太久没有做题，C题读错题写了40分钟，然后D出了思路没时间写了。

# 2023.2.26

VP2020济南

# 2023.2.27

同时开始写一写稍微难一点点的题

## [NK52185L](NK52185L.cpp)

二进制数位dp

考虑到某个数字加m如果不进位的话只能让后面的7位二进制发生变化，如果进位的话将产生进位，但也只有一次，记录连续的1的个数就可以计算出来进位的贡献了。
所以使用数位dp，dp到后7位时暴力计算方案，暴力计算方案的时候考虑是否产生进位。并分类讨论即可

## [NK52185J](NK52185J.cpp)

黑白染色之后构造分类方式

读题之后发现，如果有某一位两个点都是0那么这两个点必定没有边，通过这个性质，对这个树进行黑白染色。
黑白染色之后，同色点之间必定没有边，那么使用两位二进制就可以把同色点全部分开。然后还剩下一些边为不相邻的黑白点之间的边，因为黑色点和白色点总和为n，那么必定有一种颜色的点的个数$<
=\frac{1}{2}$对于点数较小的集合，按照标号依次分配二进制位为0。对于另一个颜色的集合，其在分配的二进制位中只有与其相邻的异色点对应编号的二进制位位1，其他均为0。

## [CF1789E](CF1789E.cpp)

注意到上取整和下取整最多相差1，然后进行分类讨论。

如果上取整和下取整相同，那么